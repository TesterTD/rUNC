<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rUNC — Документация Тестера</title>
   <link rel="icon" type="image/png" href="logo2.png" />   
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css" id="hljs-theme-light" disabled>

    <style>
        :root {
            --ease-in-out-cubic: cubic-bezier(0.65, 0, 0.35, 1);
            --transition-speed-fast: 0.2s;
            --transition-speed-med: 0.3s;
        }

        :root, :root.dark-theme {
            --primary-color: #529dff;
            --background-color: #0d1117;
            --bg-level-1: #161b22;
            --bg-level-2: #21262d;
            --bg-level-3: #2a3038;
            --text-color: #c9d1d9;
            --text-secondary-color: #8b949e;
            --glow-color: rgba(82, 157, 255, 0.2);
            --border-color: #30363d;
            --border-color-hover: #8b949e;
            --border-radius-sm: 8px;
            --border-radius-md: 12px;
            --font-body: 'Manrope', sans-serif;
            --font-code: 'JetBrains Mono', monospace;
            --scrollbar-thumb-color: #2a3038;
            --scrollbar-thumb-color-hover: #3e444c;
            --code-inline-color: #79c0ff;
        }

        :root.light-theme {
            --primary-color: #2563eb;
            --background-color: #f6f8fa;
            --bg-level-1: #ffffff;
            --bg-level-2: #f0f3f8;
            --bg-level-3: #e8ecf2;
            --text-color: #1f2328;
            --text-secondary-color: #57606a;
            --glow-color: rgba(37, 99, 235, 0.15);
            --border-color: #d0d7de;
            --border-color-hover: #2563eb;
            --scrollbar-thumb-color: #c1c8d4;
            --scrollbar-thumb-color-hover: #a8b1c2;
            --code-inline-color: #2563eb;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }

        body {
            font-family: var(--font-body);
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
            transition: background-color var(--transition-speed-med) var(--ease-in-out-cubic), color var(--transition-speed-med) var(--ease-in-out-cubic);
        }
        
        #preloader {
            position: fixed;
            inset: 0;
            background-color: var(--background-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s var(--ease-in-out-cubic), visibility 0.5s;
            gap: 20px;
            visibility: visible;
        }
        #preloader.loaded {
            opacity: 0;
            visibility: hidden;
        }
        .loader-logo {
            font-family: var(--font-body);
            font-weight: 800;
            font-size: 32px;
            color: var(--primary-color);
            animation: pulse-logo 1.5s ease-in-out infinite alternate;
        }
        @keyframes pulse-logo {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.05); }
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .ripple {
            position: fixed;
            border-radius: 50%;
            background-color: var(--primary-color);
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: ripple-effect 0.75s var(--ease-in-out-cubic);
            z-index: 9990;
        }
        @keyframes ripple-effect {
            from { width: 0; height: 0; opacity: 0.4; }
            to { width: 100px; height: 100px; opacity: 0; }
        }

        #background-glow {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(800px circle at 10% 20%, var(--glow-color), transparent 70%),
                        radial-gradient(600px circle at 90% 85%, rgba(66, 153, 225, 0.1), transparent 70%);
            animation: subtle-glow-move 25s ease-in-out infinite alternate;
            z-index: -1;
            will-change: opacity, transform;
            transition: opacity var(--transition-speed-med);
        }
        
        .light-theme #background-glow { opacity: 0.6; }

        @keyframes subtle-glow-move {
            0% { transform: translate(-5%, -10%) scale(1); opacity: 0.8; }
            100% { transform: translate(5%, 10%) scale(1.2); opacity: 1; }
        }

        .main-layout { display: grid; grid-template-columns: 290px 1fr; width: 100%; height: 100%; }

        .sidebar {
            background-color: var(--bg-level-1);
            border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column;
            height: 100vh;
            transition: background-color var(--transition-speed-med), border-color var(--transition-speed-med);
        }

        .sidebar-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            display: flex; flex-direction: column; gap: 20px;
        }

        .logo-area { display: flex; align-items: center; justify-content: space-between; }
        .logo-area h1 { font-size: 26px; font-weight: 800; color: var(--text-color); letter-spacing: -0.5px; }

        .search-container { position: relative; }
        .search-icon { position: absolute; top: 50%; left: 14px; transform: translateY(-50%); color: var(--text-secondary-color); pointer-events: none; transition: color var(--transition-speed-fast); }
        .search-bar {
            width: 100%;
            background-color: var(--bg-level-2);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            color: var(--text-color);
            font-family: var(--font-body);
            font-size: 15px;
            padding: 10px 16px 10px 42px;
            transition: border-color var(--transition-speed-fast), box-shadow var(--transition-speed-fast);
        }
        .search-bar::placeholder { color: var(--text-secondary-color); opacity: 0.7; }
        .search-bar:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px var(--glow-color); }
        .search-bar:focus + .search-icon { color: var(--primary-color); }

        .sidebar nav { flex-grow: 1; overflow-y: auto; padding: 16px; }
        .sidebar nav::-webkit-scrollbar { width: 10px; }
        .sidebar nav::-webkit-scrollbar-track { background: transparent; }
        .sidebar nav::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-color); border-radius: 5px; border: 3px solid var(--bg-level-1); }
        .sidebar nav::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-color-hover); }

        .sidebar ul { list-style-type: none; }
        .sidebar-group-title {
            font-size: 13px; font-weight: 700; text-transform: uppercase;
            color: var(--text-secondary-color); margin: 24px 0 10px 12px;
            letter-spacing: 0.8px;
        }

        .sidebar li a {
            display: flex; align-items: center; color: var(--text-secondary-color);
            text-decoration: none; padding: 9px 12px; margin: 4px 0;
            border-radius: var(--border-radius-sm); font-size: 15px; font-weight: 500;
            transition: background-color var(--transition-speed-fast) ease, color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
        }
        .sidebar li a:hover { background-color: var(--bg-level-2); color: var(--text-color); transform: translateX(4px); }
        .sidebar li a.active { color: var(--primary-color); background-color: var(--bg-level-3); }

        .theme-toggle-btn {
            background: none; border: 1px solid var(--border-color); color: var(--text-secondary-color);
            width: 36px; height: 36px; border-radius: var(--border-radius-sm);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all var(--transition-speed-fast);
        }
        .theme-toggle-btn:hover { border-color: var(--border-color-hover); color: var(--primary-color); transform: scale(1.05); }
        .theme-toggle-btn svg { width: 18px; height: 18px; }
        .theme-toggle-btn .icon-sun { display: none; }
        .light-theme .theme-toggle-btn .icon-moon { display: none; }
        .light-theme .theme-toggle-btn .icon-sun { display: block; }
        
        .main-content { overflow-y: auto; scroll-padding-top: 32px; }
        .container { max-width: 960px; margin: 0 auto; padding: 48px 40px; }
        section { padding-top: 32px; margin-bottom: 56px; }

        h2 {
            font-size: clamp(2rem, 5vw, 2.25rem); font-weight: 800;
            color: var(--text-color); border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px; margin-bottom: 24px;
            letter-spacing: -1px;
        }
        h3 { font-size: 22px; font-weight: 700; margin-top: 40px; margin-bottom: 20px; }

        p, li { font-size: 16px; line-height: 1.8; color: var(--text-secondary-color); margin-bottom: 16px; }
        a { color: var(--primary-color); text-decoration: none; transition: opacity var(--transition-speed-fast); font-weight: 500;}
        a:hover { text-decoration: underline; opacity: 0.8; }
        
        ul { padding-left: 20px; }

        code:not(pre > code) {
            font-family: var(--font-code); background-color: var(--bg-level-2);
            color: var(--code-inline-color); padding: 3px 6px;
            border-radius: 6px; font-size: 0.9em;
            border: 1px solid var(--border-color);
        }

        pre code { padding: 0; border: none; background: transparent; color: inherit; }
        .code-block-wrapper {
            position: relative; margin: 24px 0; border-radius: var(--border-radius-md);
            overflow: hidden; border: 1px solid var(--border-color);
        }
        .code-block-header {
            background-color: var(--bg-level-1); padding: 12px 18px;
            color: var(--text-secondary-color); font-size: 14px; font-family: var(--font-code);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        
        .copy-button {
            background: none; border: none; color: var(--text-secondary-color); padding: 6px 10px;
            border-radius: var(--border-radius-sm); cursor: pointer; font-family: var(--font-body);
            font-size: 13px; font-weight: 500;
            transition: background-color var(--transition-speed-fast), color var(--transition-speed-fast);
            display: flex; align-items: center; gap: 8px;
        }
        .copy-button:hover { background-color: var(--bg-level-3); color: var(--text-color); }
        .copy-button svg { width: 16px; height: 16px; }

        pre {
            margin: 0; background-color: var(--bg-level-2);
            padding: 20px; overflow-x: auto;
            line-height: 1.7; font-size: 14px;
        }
        .light-theme pre { background-color: #f6f8fa; }

        .note {
            background-color: var(--bg-level-2);
            border-left: 3px solid var(--primary-color);
            padding: 20px; margin-top: 24px;
            border-radius: 0 var(--border-radius-sm) var(--border-radius-sm) 0;
            border: 1px solid var(--border-color); border-left-width: 3px;
        }
        .note p { color: var(--text-color); margin: 0; }

        .syntax-block {
            background-color: var(--bg-level-2); padding: 16px 20px;
            border-radius: var(--border-radius-md); margin: 20px 0; font-size: 14px;
            font-family: var(--font-code); border: 1px solid var(--border-color); color: var(--text-color);
            overflow-x: auto; white-space: pre;
        }
        .syntax-block .kw { color: #ff7b72; } /* Словосочетания: Функции(я) */
        .syntax-block .fn { color: #a29bff; } /* Имена функций */
        .syntax-block .ty { color: #79c0ff; } /* Виды: строки, функции */
        .syntax-block .op { color: #ff7b72; } /* Операторы */
        .light-theme .syntax-block .kw { color: #d73a49; }
        .light-theme .syntax-block .fn { color: #6f42c1; }
        .light-theme .syntax-block .ty { color: #005cc5; }
        .light-theme .syntax-block .op { color: #d73a49; }
    </style>
</head>

<body>
<div id="preloader">
    <div class="loader-logo">rUNC</div>
    <div class="spinner"></div>
</div>
<div id="background-glow"></div>
<div class="main-layout">
<aside class="sidebar">
<div class="sidebar-header">
    <div class="logo-area">
        <h1>rUNC</h1>
        <button id="themeToggle" class="theme-toggle-btn" title="Переключить тему">
            <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>
    </div>
    <div class="search-container">
        <input type="text" id="searchBar" class="search-bar" placeholder="Поиск функций...">
        <span class="search-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></span>
    </div>
</div>
<nav id="sidebar-nav">
<ul>
<li class="sidebar-group-title">Введение</li>
<li><a href="#intro">О Тестере</a></li>
<li><a href="#faq">FAQ</a></li>

<li class="sidebar-group-title">Основные Функции</li>
<li><a href="#newcclosure">newcclosure</a></li>
<li><a href="#hookfunction">hookfunction</a></li>
<li><a href="#restorefunction">restorefunction</a></li>
<li><a href="#cloneref">cloneref</a></li>
<li><a href="#compareinstances">compareinstances</a></li>
<li><a href="#loadstring">loadstring</a></li>
<li><a href="#firesignal">firesignal</a></li>
<li><a href="#identifyexecutor">identifyexecutor</a></li>
<li><a href="#isrbxactive">isrbxactive</a></li>
<li><a href="#gethui">gethui</a></li>

<li class="sidebar-group-title">Типы и Замыкания</li>
<li><a href="#closure-checks">is(l/c/executor)closure</a></li>
<li><a href="#isnewcclosure">isnewcclosure</a></li>
<li><a href="#isfunctionhooked">isfunctionhooked</a></li>
<li><a href="#replaceclosure">replaceclosure</a></li>
<li><a href="#clonefunction">clonefunction</a></li>
<li><a href="#newlclosure">newlclosure</a></li>
<li><a href="#checkcaller">checkcaller</a></li>

<li class="sidebar-group-title">Мета-Операции</li>
<li><a href="#getrawmetatable">getrawmetatable</a></li>
<li><a href="#setrawmetatable">setrawmetatable</a></li>
<li><a href="#hookmetamethod">hookmetamethod</a></li>

<li class="sidebar-group-title">Скрипты и Среда</li>
<li><a href="#environments">getgenv / getrenv / getsenv</a></li>
<li><a href="#threadidentity">get/setthreadidentity</a></li>
<li><a href="#getscripts">getscripts</a></li>
<li><a href="#getrunningscripts">getrunningscripts</a></li>
<li><a href="#getloadedmodules">getloadedmodules</a></li>
<li><a href="#getscriptbytecode">getscriptbytecode</a></li>
<li><a href="#getscriptclosure">getscriptclosure</a></li>
<li><a href="#getscripthash">getscripthash</a></li>
<li><a href="#getfunctionhash">getfunctionhash</a></li>
<li><a href="#getcallingscript">getcallingscript</a></li>
<li><a href="#queue_on_teleport">queue_on_teleport</a></li>

<li class="sidebar-group-title">Работа с Памятью и GC</li>
<li><a href="#getgc">getgc</a></li>
<li><a href="#getnilinstances">getnilinstances</a></li>
<li><a href="#getinstances">getinstances</a></li>
<li><a href="#getreg">getreg</a></li>
<li><a href="#cache">cache.*</a></li>

<li class="sidebar-group-title">Взаимодействие с Объектами</li>
<li><a href="#getconnections">getconnections</a></li>
<li><a href="#getcallbackvalue">getcallbackvalue</a></li>
<li><a href="#readonly-checks">set/isreadonly</a></li>
<li><a href="#scriptable-checks">set/isscriptable</a></li>
<li><a href="#hidden-properties">get/sethiddenproperty</a></li>
<li><a href="#simulation-radius">get/setsimulationradius</a></li>
<li><a href="#firetouchinterest">firetouchinterest</a></li>
<li><a href="#fireclickdetector">fireclickdetector</a></li>
<li><a href="#fireproximityprompt">fireproximityprompt</a></li>
<li><a href="#replicatesignal">replicatesignal</a></li>

<li class="sidebar-group-title">Взаимодействие с Клиентом</li>
<li><a href="#fpscap">get/setfpscap</a></li>
<li><a href="#messagebox">messagebox</a></li>
<li><a href="#clipboard">get/setclipboard</a></li>
<li><a href="#mouse-emulation">Эмуляция мыши</a></li>

<li class="sidebar-group-title">Параллелизм и Акторы</li>
<li><a href="#actors-library">Actors API</a></li>

<li class="sidebar-group-title">2D Рендеринг</li>
<li><a href="#drawing">Drawing</a></li>

<li class="sidebar-group-title">Отладка (Debug)</li>
<li><a href="#debug-upvalues">debug.(get/set)upvalue(s)</a></li>
<li><a href="#debug-constants">debug.(get/set)constant(s)</a></li>
<li><a href="#debug-stack">debug.(get/set)stack</a></li>
<li><a href="#debug-protos">debug.getproto(s)</a></li>
<li><a href="#debug-metatable">debug.setmetatable</a></li>
<li><a href="#debug-getinfo">debug.getinfo</a></li>
<li><a href="#debug-more">Другие debug-функции</a></li>

<li class="sidebar-group-title">Криптография и Сжатие</li>
<li><a href="#crypto-base64">crypt.base64*</a></li>
<li><a href="#crypto-encrypt">crypt.encrypt/decrypt</a></li>
<li><a href="#crypto-generate">crypt.generate*</a></li>
<li><a href="#crypto-hash">crypt.hash</a></li>
<li><a href="#compression">lz4compress/decompress</a></li>

<li class="sidebar-group-title">Файловая Система и Сеть</li>
<li><a href="#request">request / http_request</a></li>
<li><a href="#file-ops">Файловые операции</a></li>
<li><a href="#folder-ops">Операции с папками</a></li>
<li><a href="#loadfile">loadfile</a></li>
<li><a href="#getcustomasset">getcustomasset</a></li>
<li><a href="#websocket">WebSocket</a></li>
</ul>
</nav>
</aside>
<main class="main-content">
<div class="container">

<section id="intro">
<h2>rUNC Executor Test</h2>
<p>
<b>rUNC</b> — это комплексный, открытый набор тестов для глубокой проверки функциональности среды исполнения Luau. Он оценивает корректность реализации десятков функций, выявляя потенциальные проблемы, уязвимости и несоответствия стандарту.
</p>
<h3>Запуск теста</h3>
<p>Чтобы запустить тест, выполните следующую команду в вашей среде исполнения:</p>
<div class="code-block-wrapper">
 <div class="code-block-header"><span>Luau</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">loadstring(game:HttpGet("https://raw.githubusercontent.com/TesterTD/rUNC/main/rUNC.lua"))()</code></pre>
</div>
</section>

<section id="faq">
<h2>FAQ</h2>
<h3>Что такое rUNC?</h3>
<p><strong>rUNC</strong> — инструмент для комплексного тестирования окружения, который проверяет наличие и корректную работу десятков ключевых функций: от базовых (например, <code>newcclosure</code>) до продвинутых, связанных с отладкой, метатаблицами и взаимодействием с движком Roblox.</p> 
<p>В отличие от оригинального <a href="https://github.com/unified-naming-convention/NamingStandard/tree/main" target="_blank" rel="noopener noreferrer">UNC</a>, созданного как единый стандарт именования и API, <strong>rUNC</strong> имитирует реальные сценарии использования функций, чтобы убедиться, что они действительно работают так, как должны, а не просто существуют для прохождения базовых проверок.</p>
<h3>Что означает "Skid Rate"?</h3>
<p>Это условный показатель, который отражает процент неудачных тестов для критически важных или базовых функций. Высокий Skid Rate может указывать на низкое качество, эмуляцию или неполную реализацию среды исполнения.</p>
<h3>В чем цель этого проекта?</h3>
<p>Тест был создан, чтобы доказать, что надежная проверка среды исполнения может и должна быть с открытым исходным кодом. Он служит альтернативой закрытым системам, которые анализируют среду анонимно, не позволяя пользователям изучить сам механизм проверки.</p>
<h3>Почему нет тестов для WebSocket?</h3>
<p>Тесты для <code>WebSocket</code> намеренно исключены, так как его реализация часто приводит к нестабильной работе или вылетам в различных средах исполнения. Вместо этого предоставляется общая документация по его API.</p>
<h3>Где большинство примеров?</h3>
<p>Остаточные примеры можно посмотреть в самом открытом коде для проверки функций. Я не вижу смысла оставлять их везде, к тому же на разных инжекторах они реагируют по‑разному, хоть и проходят тест они одинаково хорошо или плохо.</p>
</section>


<section id="newcclosure">
<h2>newcclosure</h2>
<p>Создает "C-замыкание" из функции Luau. Это позволяет маскировать Luau-функции под встроенные C-функции, что изменяет их поведение при обработке ошибок и для таких проверок, как <code>iscclosure</code>.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">newcclosure</span>(func: <span class="ty">function</span>): <span class="ty">function</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Простое оборачивание</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local my_func = function() return "Hello from Luau!" end
local c_func = newcclosure(my_func)

print(iscclosure(my_func)) --> false
print(iscclosure(c_func)) --> true
print(c_func()) --> Hello from Luau!</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Маскировка ошибок</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local error_func = newcclosure(function()
    error("This is a custom error")
end)

-- pcall вернет ошибку без информации о скрипте и строке, как будто она из C-кода
local success, message = pcall(error_func)
print(success, message) --> false, This is a custom error</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет несколько ключевых аспектов:</p>
<ul>
    <li><b>Создание и тип:</b> Убеждается, что <code>newcclosure</code> успешно создает функцию и что <code>iscclosure</code> правильно идентифицирует её как C-замыкание.</li>
    <li><b>Сохранение семантики:</b> Проверяет, что обернутая функция возвращает те же значения (включая множественные возвраты), что и оригинал.</li>
    <li><b>Обработка yield:</b> Тестирует, может ли <code>newcclosure</code> оборачивать "yielding" функции (например, с <code>task.wait</code>) и корректно возобновлять их выполнение.</li>
    <li><b>Маскировка ошибок:</b> Удостоверяется, что ошибки, возникающие внутри C-замыкания, выглядят как ошибки из C-кода (без stack trace).</li>
    <li><b>Вложенность:</b> Проверяет возможность создавать <code>newcclosure</code> из функции, которая уже является C-замыканием.</li>
</ul>
</section>

<section id="hookfunction">
<h2>hookfunction</h2>
<p>Позволяет перехватить вызовы одной функции и заменить их другой. Возвращает оригинальную функцию, чтобы её можно было вызвать внутри перехватчика для сохранения исходной логики. Это мощный инструмент для логирования, модификации поведения или блокировки функций.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">hookfunction</span>(target: <span class="ty">function</span>, hook: <span class="ty">function</span>): <span class="ty">function</span> <span class="op">-- Возвращает оригинал</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Логирование вызовов `warn`</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local original_warn
original_warn = hookfunction(warn, function(...)
    print("[WARN CALLED]:", ...)
    return original_warn(...)
end)

warn("Test message")</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Модификация аргументов `print`</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local old_print
old_print = hookfunction(print, function(...)
    local args = {...}
    table.insert(args, 1, "[HOOKED]")
    return old_print(table.unpack(args))
end)

print("Hello", "world") -- Выведет: [HOOKED] Hello world
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проводит комплексную проверку:</p>
<ul>
    <li><b>Базовый перехват:</b> Удостоверяется, что вызов оригинальной функции теперь выполняет код хука.</li>
    <li><b>Возврат оригинала:</b> Проверяет, что <code>hookfunction</code> возвращает рабочую копию оригинальной функции.</li>
    <li><b>Обработка ошибок:</b> Тестирует, что ошибки в оригинальной функции могут быть перехвачены и обработаны внутри хука.</li>
    <li><b>Работа с C-функциями:</b> Убеждается, что можно перехватывать глобальные C-функции, такие как <code>warn</code>.</li>
    <li><b>Восстановление:</b> Проверяет, что хук можно снять, вызвав <code>hookfunction</code> повторно с оригинальной функцией.</li>
    <li><b>Совместимость с `newcclosure`:</b> Тест запускается дважды: с обычной Luau-функцией и с C-замыканием в качестве хука.</li>
</ul>
</section>

<section id="restorefunction">
<h2>restorefunction</h2>
<p>Полностью восстанавливает оригинальное состояние функции, которая была ранее изменена с помощью <code>hookfunction</code>. Удаляет все установленные хуки, включая вложенные, возвращая функцию к её первоначальному состоянию.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">restorefunction</span>(target: <span class="ty">function</span>)</div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Восстановление `print` после хука</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">hookfunction(print, function(...) end) -- Блокируем print
print("This will not appear")

restorefunction(print)
print("This will appear now") --> This will appear now</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Снятие нескольких хуков</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local function my_func() return "original" end

local old1 = hookfunction(my_func, function() return "hooked 1" end)
local old2 = hookfunction(my_func, function() return "hooked 2" end)

print(my_func()) --> "hooked 2"

restorefunction(my_func)
print(my_func()) --> "original"
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Ошибка на не-хукнутой функции:</b> Убеждается, что вызов <code>restorefunction</code> на обычной функции вызывает ошибку.</li>
    <li><b>Полное восстановление:</b> После установки нескольких хуков на одну функцию, проверяет, что <code>restorefunction</code> возвращает её к самому первому, оригинальному состоянию.</li>
    <li><b>Изоляция:</b> Проверяет, что восстановление одной функции не затрагивает хуки, установленные на другие функции.</li>
    <li><b>Повторное восстановление:</b> Убеждается, что повторный вызов <code>restorefunction</code> на уже восстановленной функции вызывает ошибку.</li>
</ul>
</section>

<section id="cloneref">
<h2>cloneref</h2>
<p>Создает "легкую" копию (ссылку) на <code>Instance</code>. Клон и оригинал указывают на один и тот же объект в памяти. Это означает, что изменение свойства у клона изменит его и у оригинала. Уничтожение оригинала делает клон невалидным. Защищает от __mode атак, то есть детекты с помощью weak tables.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">cloneref</span>(target: <span class="ty">Instance</span>): <span class="ty">Instance</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Демонстрация работы ссылок</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local part_original = Instance.new("Part", workspace)
local part_clone = cloneref(part_original)

print(part_original == part_clone) --> false (ссылки разные)

part_clone.Name = "NewName"
print(part_original.Name) --> "NewName" (объект один)
</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Валидность после Destroy</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local part_original = Instance.new("Part", workspace)
local part_clone = cloneref(part_original)

part_original:Destroy()
task.wait(0.1)

local success, result = pcall(function()
    return part_clone.Parent
end)
print(success, result) --> true nil</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Создание и неравенство:</b> Убеждается, что клон успешно создается, но при этом <code>original ~= clone</code> возвращает <code>true</code>.</li>
    <li><b>Общие сигналы:</b> Проверяет, что подключение к сигналу на клоне влияет на оригинал.</li>
    <li><b>Совместное уничтожение:</b> После вызова <code>:Destroy()</code> на оригинале, тест проверяет, что и оригинал, и клон удалены из игрового дерева.</li>
    <li><b>Невалидность:</b> Убеждается, что после уничтожения оригинала, доступ к свойствам или методам клона вызывает ошибку или возвращает `nil`.</li>
</ul>
</section>

<section id="compareinstances">
<h2>compareinstances</h2>
<p>Сравнивает два `Instance`, чтобы определить, указывают ли они на один и тот же базовый объект. Это особенно полезно при работе с `cloneref`, так как обычное сравнение `==` вернет `false` для оригинала и его клона.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">compareinstances</span>(a: <span class="ty">Instance</span>, b: <span class="ty">Instance</span>): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Сравнение оригинала и клона</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local original = Instance.new("Part")
local ref = cloneref(original)

print(original == ref) --> false
print(compareinstances(original, ref)) --> true</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Сравнение разных объектов</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local part1 = Instance.new("Part")
local part2 = Instance.new("Part")

print(compareinstances(part1, part2)) --> false
print(compareinstances(part1, part1)) --> true</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Идентичность:</b> Проверяет, что <code>compareinstances(inst, inst)</code> возвращает `true`.</li>
    <li><b>Сравнение с клоном:</b> Убеждается, что <code>compareinstances(inst, cloneref(inst))</code> возвращает `true`.</li>
    <li><b>Различие:</b> Проверяет, что <code>compareinstances(inst1, inst2)</code> для разных объектов возвращает `false`.</li>
</ul>
</section>

<section id="loadstring">
<h2>loadstring</h2>
<p>Компилирует строку кода Luau в функцию без её немедленного выполнения. Если в коде есть синтаксическая ошибка, возвращает `nil` и сообщение об ошибке.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">loadstring</span>(code: <span class="ty">string</span>, chunkName: <span class="ty">string</span><span class="op">?</span>): (<span class="ty">function</span><span class="op">?</span>, <span class="ty">string</span><span class="op">?</span>)</div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Динамическое выполнение кода</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local code = "getgenv().a = 10; return a + 5"
local func, err = loadstring(code)

if func then
    print("Result:", func()) --> Result: 15
    print("Global var:", getgenv().a) --> Global var: 10
else
    warn("Failed to compile code:", err)
end</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Обработка ошибок компиляции</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local invalid_code = "local a =="
local func, err = loadstring(invalid_code, "MyChunk")

if not func then
    print("Error:", err) --> Error: [MyChunk]:1: Expected identifier...
end</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Компиляция и исполнение:</b> Проверяет, что `loadstring` для корректного кода возвращает функцию, которая выполняется и возвращает правильное значение.</li>
    <li><b>Доступ к окружению:</b> Убеждается, что код может изменять глобальное окружение (<code>getgenv</code>).</li>
    <li><b>Обработка невалидного кода:</b> Проверяет, что для кода с ошибкой `loadstring` возвращает `nil` и строку с сообщением об ошибке.</li>
    <li><b>Имя чанка:</b> Удостоверяется, что имя чанка (`chunkName`) появляется в сообщении об ошибке.</li>
</ul>
</section>

<section id="firesignal">
<h2>firesignal</h2>
<p>Вызывает сигнал (`RBXScriptSignal`) с указанными аргументами. По сути, это способ программно имитировать срабатывание сигнала.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">firesignal</span>(signal: <span class="ty">RBXScriptSignal</span>, ...<span class="op">:</span> <span class="ty">any</span>)</div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Имитация клика по кнопке</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local button = Instance.new("TextButton")
button.MouseButton1Click:Connect(function()
    print("Button was clicked programmatically!")
end)

firesignal(button.MouseButton1Click)</code></pre>
</div>
<div class="code-block-wrapper">
<div class="code-block-header"><span>2. Вызов BindableEvent с аргументами</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local bindable = Instance.new("BindableEvent")
bindable.Event:Connect(function(player, score)
    print(player.Name .. " scored " .. score)
end)

local player = game:GetService("Players").LocalPlayer
firesignal(bindable.Event, player, 100)</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Вызов с аргументами и без:</b> Проверяет, что вызовы `firesignal` корректно активируют подключенную функцию и передают ей аргументы (или `nil`).</li>
    <li><b>Отключенные соединения:</b> Проверяет, что `firesignal` не вызывает соединения, которые были отключены через `:Disconnect()`.</li>
</ul>
</section>

<section id="identifyexecutor">
<h2>identifyexecutor</h2>
<p>Возвращает имя и версию текущей среды исполнения (эксплойта).</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">identifyexecutor</span>(): (<span class="ty">string</span> <span class="op">--[[name]]</span>, <span class="ty">string</span> <span class="op">--[[version]]</span>)</div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Вывод информации в консоль</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local name, version = identifyexecutor()
print(`Executor: {name} v{version}`)</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Успешное выполнение:</b> Проверяет, что функция выполняется без ошибок.</li>
    <li><b>Тип и содержимое:</b> Убеждается, что оба возвращаемых значения — это непустые строки, соответствующие имени и версии.</li>
</ul>
</section>

<section id="isrbxactive">
<h2>isrbxactive</h2>
<p>Проверяет, активно ли окно Roblox. Возвращает `true`, если окно находится в фокусе, и `false` в противном случае. Полезно для скриптов, которые должны приостанавливать свою работу, когда игрок сворачивает игру.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">isrbxactive</span>(): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Пауза цикла, когда игра неактивна</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">task.spawn(function()
    while true do
        if isrbxactive() then
            -- Выполняем действия, только если игра в фокусе
            print("Processing...")
        end
        task.wait(1)
    end
end)</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Возвращаемое значение:</b> Тест просто вызывает функцию и проверяет, что она выполняется без ошибок и возвращает `true`, так как во время выполнения теста окно по определению активно.</li>
</ul>
</section>

<section id="gethui">
<h2>gethui</h2>
<p>Возвращает скрытый контейнер интерфейса (`Instance`), предназначенный для безопасного размещения UI-элементов. Объекты в `gethui` Если так подумать, это CoreGui parent на максималках, cloneref с CoreGui будет в разы лучше.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">gethui</span>(): <span class="ty">Instance</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Создание постоянного GUI</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local permanentGui = Instance.new("ScreenGui")
permanentGui.ResetOnSpawn = false
permanentGui.Parent = gethui()</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Тип объекта:</b> Проверяет, что `gethui` возвращает объект типа `Instance`.</li>
    <li><b>Функциональность родителя:</b> Убеждается, что в возвращенный объект можно помещать другие `Instance` (например, `ScreenGui`).</li>
</ul>
</section>

<section id="closure-checks">
<h2>islclosure / iscclosure / isexecutorclosure</h2>
<p>Эти функции проверяют тип замыкания (closure). Они используются для определения, является ли функция обычной Luau-функцией, C-функцией или специфичной для эксплойта.</p>
<ul>
    <li><code>islclosure(func)</code>: Возвращает `true`, если `func` — это стандартная функция, написанная на Luau.</li>
    <li><code>iscclosure(func)</code>: Возвращает `true`, если `func` — это C-функция, включая <code>newcclosure</code>.</li>
    <li><code>isexecutorclosure(func)</code>: Возвращает `true`, если функция принадлежит среде исполнения.</li>
</ul>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Проверка разных типов функций</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local lua_func = function() end
local c_func_wrapped = newcclosure(lua_func)
local c_func_native = print
local exploit_func = getgenv

print("lua_func is lclosure:", islclosure(lua_func))             --> true
print("c_func_native is cclosure:", iscclosure(c_func_native)) --> true
print("exploit_func is executorclosure:", isexecutorclosure(exploit_func)) --> true
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет все три функции на разных типах целей: Luau-функция, стандартная C-функция (`print`), обернутая C-функция (`newcclosure`) и функция среды исполнения (`getgenv`).</p>
</section>

<section id="isnewcclosure">
<h2>isnewcclosure</h2>
<p>Определяет, была ли C-функция создана с помощью <code>newcclosure</code>. Это позволяет отличить "настоящие" встроенные C-функции от Luau-функций, замаскированных под C.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">isnewcclosure</span>(func: <span class="ty">function</span>): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Отличие обертки от нативной функции</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local wrapped = newcclosure(function() end)

print("For wrapped function:", isnewcclosure(wrapped)) --> true
print("For native 'print':", isnewcclosure(print))   --> false
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет, что функция возвращает <code>true</code> для результата <code>newcclosure</code> и <code>false</code> для обычной Luau-функции.</p>
</section>

<section id="isfunctionhooked">
<h2>isfunctionhooked</h2>
<p>Проверяет, была ли функция перехвачена (захукана) с помощью <code>hookfunction</code>.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">isfunctionhooked</span>(func: <span class="ty">function</span>): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Проверка состояния хука</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local function my_func() end
print("Before hook:", isfunctionhooked(my_func)) -- false

local old = hookfunction(my_func, function() end)
print("After hook:", isfunctionhooked(my_func)) -- true

hookfunction(my_func, old) -- restore original
print("After restore:", isfunctionhooked(my_func)) -- false (Но, скорее будет true, на что можно надеяться, когда ты восстанавливаешь функцию не через restorefunction💀)
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет, что функция возвращает <code>false</code> для обычной функции, <code>true</code> после применения `hookfunction`, и снова <code>false</code> после восстановления.</p>
</section>

<section id="replaceclosure">
<h2>replaceclosure</h2>
<p>Заменяет код одной Luau-функции кодом другой. При этом новая функция получает доступ к upvalue'ам (внешним локальным переменным) оригинальной функции.</p>
<div class="note"><p><b>Внимание:</b> Эта функция может легко привести к сбою, если новая функция неправильно работает с upvalue'ами старой.</p></div>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">replaceclosure</span>(target: <span class="ty">function</span>, new: <span class="ty">function</span>)</div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Изменение поведения и доступ к upvalue</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local counter = 10
local function original()
    counter = counter + 1
    return "Original was called"
end

local function replacement()
    return "Replacement was called, counter is: " .. counter
end

replaceclosure(original, replacement)
print(original()) --> Replacement was called, counter is: 10
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Подмена:</b> Убеждается, что после замены вызов оригинальной функции теперь выполняет код новой.</li>
    <li><b>Доступ к upvalue:</b> Проверяет, что замененная функция может корректно читать upvalue'ы оригинала.</li>
    <li><b>Защита C-функций:</b> Удостоверяется, что попытка заменить C-функцию вызывает ошибку.</li>
</ul>
</section>

<section id="clonefunction">
<h2>clonefunction</h2>
<p>Создает полную копию (клон) Luau-функции. Клон имеет то же самое тело и upvalue'ы, но является отдельным объектом. Хуки, примененные к оригиналу после клонирования, не влияют на клон.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">clonefunction</span>(target: <span class="ty">function</span>): <span class="ty">function</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Изоляция от хуков</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local function original()
    print("Original function")
end

local cloned = clonefunction(original)

hookfunction(original, function() print("Hooked!") end)

original() --> Hooked!
cloned()   --> Original function</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Общее окружение:</b> Убеждается, что `getfenv(original)` и `getfenv(cloned)` совпадают.</li>
    <li><b>Изоляция от `hookfunction`:</b> После клонирования хукает оригинал и проверяет, что клон остался неизменным.</li>
    <li><b>Работа с C-функциями:</b> Убеждается, что попытка клонировать C-функцию не вызывает ошибку (проверка эмуляции).</li>
</ul>
</section>

<section id="newlclosure">
<h2>newlclosure</h2>
<p>Создает новое Luau-замыкание из существующей Luau-функции. Это похоже на <code>clonefunction</code>, но является более низкоуровневой операцией. Новый <code>lclosure</code> разделяет код и upvalue'ы с оригиналом.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">newlclosure</span>(target: <span class="ty">function</span>): <span class="ty">function</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Создание нового Luau замыкания</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local count = 0
local function increment()
    count = count + 1
    return count
end

local lclosure_copy = newlclosure(increment)

print(increment())       --> 1
print(lclosure_copy())   --> 2
print(islclosure(lclosure_copy)) --> true
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Успешное создание:</b> Проверяет, что функция создает новое замыкание и что <code>islclosure</code> возвращает <code>true</code>.</li>
    <li><b>Общие upvalues:</b> Убеждается, что вызов оригинала и нового замыкания влияет на один и тот же upvalue.</li>
    <li><b>Ошибка на C-функциях:</b> Проверяет, что попытка использовать на C-функции вызывает ошибку.</li>
</ul>
</section>


<section id="checkcaller">
<h2>checkcaller</h2>
<p>Проверяет контекст вызова. Возвращает `true`, если вызов происходит из Luau-потока. Возвращает `false`, если вызов инициирован из C-кода (например, изнутри события движка или `newcclosure`).</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">checkcaller</span>(): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Защита от вызовов `Kick` с подробнейшим объяснением и проверкой кому принадлежит kick</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local Players = cloneref(game:GetService("Players")) --> Получаем сервис Players через cloneref (Зачем? Прочти мой документационный пост про cloneref :D)
local lp = Players.LocalPlayer                      

local old --> Переменная для хранения оригинальной функции __namecall
old = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()  --> Получаем имя вызываемого метода ("Kick")
    if self == lp and method and method:lower() == "kick" then --> Проверяем, что метод вызывается на LocalPlayer и это Kick
        if checkcaller() then   --> Если вызов из кода Executor, значит...
            warn("Попытка кика со стороны Executor была заблокирована!!! Нахуя себя кикать?") --> Логируем, что кик был от executor и посылаем нахер
            return --> Блокируем выполнение
        else  --> Если вызов из игры (Клиент попытался кикнуть)
            warn("хахаахахахаха лошок ебаный захотел кикнуть со стороны клиента") --> Логируем, что кик был от клиента, а не от Executor
            return --> Блокируем выполнение
        end
    end
    return old(self, ...) --> Если условия не совпали — вызываем оригинальный __namecall
end))

task.delay(2, function() --> Ждём 2 секунды, чтобы хук успел установиться (На всякий, вдруг твой инжектор Velocity :D)
    warn(">>> TEST: вызываем Kick от инжектора")
    lp:Kick("Если ты видишь это сообщение то это значит одно: A - твой инжектор не обладает hookmetamethod или функция крайне плохо сделана...") --> Этот вызов должен быть перехвачен хуком и заблокирован
end)

</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проводит множество проверок: базовый вызов, вызов из C-кода через `__namecall`, вызов из `newcclosure` и стабильность.</p>
</section>

<section id="getrawmetatable">
<h2>getrawmetatable</h2>
<p>Возвращает метатаблицу объекта, даже если она защищена свойством <code>__metatable</code>.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">getrawmetatable</span>(obj: <span class="ty">table</span> <span class="op">|</span> <span class="ty">userdata</span>): <span class="ty">table</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Обход защиты __metatable</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local t = {}
local mt = { __metatable = "LOCKED" }
setmetatable(t, mt)

print(getmetatable(t)) --> LOCKED
print(getrawmetatable(t) == mt) --> true</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет работу с обычной таблицей, `Instance` и сервисами. Создает таблицу с защитой `__metatable` и проверяет, что `getrawmetatable` успешно ее получает.</p>
</section>

<section id="setrawmetatable">
<h2>setrawmetatable</h2>
<p>Устанавливает метатаблицу для объекта, обходя защиту `__metatable`.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">setrawmetatable</span>(obj: <span class="ty">table</span> <span class="op">|</span> <span class="ty">userdata</span>, mt: <span class="ty">table</span> <span class="op">|</span> <span class="ty">nil</span>): <span class="ty">boolean</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Замена защищенной метатаблицы</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local t = {}
setmetatable(t, { __metatable = "LOCKED" })

local new_mt = { __index = function() return "bypassed!" end }
setrawmetatable(t, new_mt)
print(t.anything) --> bypassed!
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что `setrawmetatable` успешно устанавливает новую метатаблицу на защищенный объект и что она действительно работает.</p>
</section>

<section id="hookmetamethod">
<h2>hookmetamethod</h2>
<p>Перехватывает вызовы метаметодов (`__index`, `__namecall`, и др.) для заданного объекта. Это один из самых мощных способов изменения поведения Roblox API.</p>
<h3>Синтаксис</h3>
<div class="syntax-block"><span class="kw">function</span> <span class="fn">hookmetamethod</span>(obj: <span class="ty">userdata</span>, method: <span class="ty">string</span>, hook: <span class="ty">function</span>): <span class="ty">function</span> <span class="op">-- Возвращает оригинал</span></div>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Перехват `game:GetService()`</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local old_namecall
old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
    if getnamecallmethod():lower() == "getservice" then
        print("GetService called for:", ...)
    end
    return old_namecall(self, ...)
end)

game:GetService("Players")
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет хуки на несколько ключевых метаметодов: <code>__newindex</code>, <code>__tostring</code>, <code>__index</code>, и <code>__namecall</code>, а также возможность их восстановления.</p>
</section>

<section id="environments">
<h2>getgenv / getrenv / getsenv</h2>
<p>Предоставляют доступ к различным таблицам окружения.</p>
<ul>
    <li><code>getgenv()</code>: Глобальное окружение Executor среды.</li>
    <li><code>getrenv()</code>: Глобальное окружение Roblox, врата getrenv() к getfenv()... Осторожно с работой getrenv(), изменения легко обнаружаются с разных углов детектирования.</li>
    <li><code>getsenv(script)</code>: Локальное окружение конкретного скрипта.</li>
</ul>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Чтение окружения `getsenv`</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">-- 'Animate' - стандартный скрипт в персонаже
local animate = game.Players.LocalPlayer.Character:FindFirstChild("Animate")
if animate then
    local env = getsenv(animate)
    -- В окружении скрипта Animate есть функция onSwimming
    print(typeof(env.onSwimming)) --> function
end
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>getgenv / getrenv:</b> Проверяет, возвращается ли таблица и сохраняются ли в ней изменения.</li>
    <li><b>getsenv:</b> Проверяет получение окружения для активного `LocalScript`, ошибку на неактивном и `nil` для `ModuleScript`.</li>
</ul>
</section>

<section id="threadidentity">
<h2>getthreadidentity / setthreadidentity</h2>
<p>Функции для управления уровнем "идентичности" (контекста безопасности) текущего потока. Уровень идентичности — это число от 0 до 8.</p>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Изменение идентичности в новом потоке</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">print("Уровень потока сейчас:", getthreadidentity())

task.spawn(function()
    print("Новый поток (Уровень на данный момент):", getthreadidentity())
    setthreadidentity(6)
    print("Новый поток (После изменения):", getthreadidentity()) --> 6
end)

task.wait(0.1)
print("Основной поток уровня не был нарушен:", getthreadidentity())
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Тест проводит исчерпывающую проверку: стабильность, диапазон, изоляцию потоков, работу в `pcall` и быстрое переключение.</p>
</section>

<section id="getscripts">
<h2>getscripts</h2>
<p>Возвращает таблицу всех существующих в игре скриптовых объектов (`LocalScript`, `Script`, `ModuleScript`), независимо от того, запущены они или нет.</p>
<h3>Как проверяется в rUNC</h3>
<p>Создает новый `LocalScript` и затем проверяет, что `getscripts` находит этот свежесозданный скрипт в возвращенном списке.</p>
</section>

<section id="getrunningscripts">
<h2>getrunningscripts</h2>
<p>Возвращает таблицу всех скриптов, которые в данный момент исполняются.</p>
<h3>Как проверяется в rUNC</h3>
<p>Находит известный работающий скрипт (Animate), проверяет, что не включает неактивные скрипты, и что общее число скриптов больше нуля.</p>
</section>

<section id="getloadedmodules">
<h2>getloadedmodules</h2>
<p>Возвращает таблицу всех `ModuleScript`, которые были загружены хотя бы раз через `require()`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что известный загруженный модуль присутствует в списке, а свежесозданный, незагруженный — отсутствует.</p>
</section>

<section id="getscriptbytecode">
<h2>getscriptbytecode</h2>
<p>Возвращает скомпилированный байт-код скрипта в виде строки.</p>
<h3>Как проверяется в rUNC</h3>
<p>Убеждается, что для скрипта с кодом (Animate) возвращается непустая строка, а для скрипта без байт-кода — `nil` или пустая строка.</p>
</section>

<section id="getscriptclosure">
<h2>getscriptclosure</h2>
<p>Возвращает главное замыкание (функцию) скрипта. По сути, это "скомпилированный" результат, который можно выполнить.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что для скрипта с кодом (Animate) возвращается `function`, а для пустого — `nil`.</p>
</section>

<section id="getscripthash">
<h2>getscripthash</h2>
<p>Возвращает хэш (SHA-384) байт-кода скрипта. Это надежный способ проверить, был ли скрипт изменен.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что возвращаемое значение является валидным хэшем SHA-384. Тестирует, что для скрипта без байт-кода возвращается `nil`.</p>
</section>

<section id="getfunctionhash">
<h2>getfunctionhash</h2>
<p>Возвращает хэш (SHA-384) байт-кода Luau-функции. Работает напрямую с функциями в памяти.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что возвращается корректный хэш. Убеждается, что разные функции имеют разные хэши, а идентичные — одинаковые. Проверяет ошибку на C-функциях.</p>
</section>

<section id="getcallingscript">
<h2>getcallingscript</h2>
<p>Возвращает `script`, из которого была вызвана текущая функция. Если вызов был инициирован C-кодом, возвращает `nil`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что прямой вызов из C-потока возвращает `nil`, а вызов из Luau-функции возвращает текущий скрипт.</p>
</section>

<section id="queue_on_teleport">
<h2>queue_on_teleport</h2>
<p>Регистрирует строку с Lua-кодом, которая будет выполнена после того, как игрок телепортируется в другое место.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что вызов с валидной строкой кода не вызывает ошибок.</p>
</section>

<section id="getgc">
<h2>getgc</h2>
<p>Возвращает таблицу со всеми объектами, которые отслеживаются сборщиком мусора.</p>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>getgc(false):</b> Проверяет, что находит функции, но не таблицы.</li>
    <li><b>getgc(true):</b> Проверяет, что находит все тестовые объекты: функцию, таблицу и userdata.</li>
</ul>
</section>

<section id="getnilinstances">
<h2>getnilinstances</h2>
<p>Возвращает таблицу всех объектов `Instance`, у которых нет родителя (`Parent == nil`).</p>
<h3>Как проверяется в rUNC</h3>
<p>Убеждается, что объект без родителя присутствует в списке, а объект с родителем — нет.</p>
</section>

<section id="getinstances">
<h2>getinstances</h2>
<p>Возвращает таблицу всех `Instance`, существующих в памяти.</p>
<h3>Как проверяется в rUNC</h3>
<p>Убеждается, что свежесозданный `Instance` без родителя находится в списке.</p>
</section>

<section id="getreg">
<h2>getreg</h2>
<p>Возвращает таблицу реестра Lua, содержащую все "живые" объекты.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что находит созданный поток, и что его можно закрыть через `coroutine.close`.</p>
</section>

<section id="cache">
<h2>cache.* (invalidate, iscached, replace)</h2>
<p>Набор функций для управления внутренним кэшем ссылок на `Instance` Roblox.</p>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>invalidate:</b> Проверяет, что ссылка на объект была сброшена.</li>
    <li><b>iscached:</b> Проверяет, что объект кэширован, а после инвалидации — нет.</li>
    <li><b>replace:</b> Проверяет, что объект успешно заменён.</li>
</ul>
</section>

<section id="getconnections">
<h2>getconnections</h2>
<p>Возвращает таблицу всех объектов соединений (`RBXScriptConnection`), подключенных к данному сигналу.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет возврат таблицы, валидность соединений, доступ к `.Function`, вызов `.Fire()`, и обработку C-соединений.</p>
</section>

<section id="getcallbackvalue">
<h2>getcallbackvalue</h2>
<p>Получает функцию обратного вызова (callback), назначенную свойству объекта.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет успешное извлечение callback, его работоспособность, и корректную обработку `nil` для неустановленных или несуществующих свойств.</p>
</section>

<section id="readonly-checks">
<h2>setreadonly / isreadonly</h2>
<p>Функции для управления состоянием "только для чтения" у таблиц.</p>
<h3>Как проверяется в rUNC</h3>
<p>Устанавливает флаг и проверяет блокировку записи. Затем снимает флаг и проверяет, что запись снова возможна.</p>
</section>

<section id="scriptable-checks">
<h2>set/isscriptable</h2>
<p>Функции для управления "скриптуемостью" защищенных свойств `Instance`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет для `Humanoid.InternalHeadScale`, что оно изначально нескриптуемо, становится скриптуемым после `setscriptable(true)` (и его можно изменить), и снова становится нескриптуемым после `setscriptable(false)`.</p>
</section>

<section id="hidden-properties">
<h2>get/sethiddenproperty</h2>
<p>Функции для прямого чтения и записи скрытых свойств `Instance`, обходя стандартные проверки доступа.</p>
<div class="note"><p>В текущей версии rUNC этот тест отключен, так как в некоторых средах он может приводить к сбою.</p></div>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет чтение обычных и скрытых свойств, а также запись в скрытое свойство 'DataCost' и убеждается, что обычная запись по-прежнему вызывает ошибку.</p>
</section>

<section id="simulation-radius">
<h2>get/setsimulationradius</h2>
<p>Функции для чтения и изменения радиуса симуляции физики для игрока.</p>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Увеличение радиуса симуляции</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local originalRadius = getsimulationradius()
print("Original radius:", originalRadius)

setsimulationradius(1024)
print("New radius:", getsimulationradius()) --> 1024
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Читает исходный радиус, устанавливает новое значение, а затем снова читает его, чтобы убедиться, что оно изменилось.</p>
</section>

<section id="firetouchinterest">
<h2>firetouchinterest</h2>
<p>Искусственно вызывает событие касания (`.Touched` или `.TouchEnded`) между двумя объектами.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что `firetouchinterest` учитывает `CanTouch=false`, вызывает `Touched` с toggle=0, вызывает `TouchEnded` с toggle=1, и выбрасывает ошибки при неверных аргументах.</p>
</section>

<section id="fireclickdetector">
<h2>fireclickdetector</h2>
<p>Программно симулирует клик мыши или наведение на объект с `ClickDetector`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Последовательно вызывает `fireclickdetector` для `MouseClick`, `RightMouseClick`, `MouseHoverEnter`, `MouseHoverLeave` и проверяет, что соответствующие события сработали.</p>
</section>

<section id="fireproximityprompt">
<h2>fireproximityprompt</h2>
<p>Симулирует срабатывание `ProximityPrompt` от лица `LocalPlayer`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что вызов не вызывает ошибок и что событие `Triggered` срабатывает с `LocalPlayer` в качестве аргумента.</p>
</section>

<section id="replicatesignal">
<h2>replicatesignal</h2>
<p>Используется для удаленной репликации событий ввода, таких как `MouseWheelForward`/`Backward`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что вызов с корректными аргументами не вызывает ошибок, а с неполными — вызывает.</p>
</section>

<section id="fpscap">
<h2>get/setfpscap</h2>
<p>Функции для чтения и установки ограничения кадров в секунду (FPS).</p>
<h3>Как проверяется в rUNC</h3>
<p>Читает cap, сверяет его с реальным FPS, устанавливает новый cap, проверяет что реальный FPS изменился, затем восстанавливает исходное значение.</p>
</section>

<section id="messagebox">
<h2>messagebox</h2>
<p>Отображает системное диалоговое окно (message box).</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что вызов не вызывает ошибок, и определяет, является ли вызов синхронным (блокирующим) или асинхронным.</p>
</section>

<section id="clipboard">
<h2>get/setclipboard</h2>
<p>Функции для работы с буфером обмена пользователя.</p>
<h3>Примеры</h3>
<div class="code-block-wrapper">
<div class="code-block-header"><span>1. Копирование и чтение</span><button class="copy-button" onclick="copyCode(this)"><span>Копировать</span></button></div>
<pre><code class="language-lua">local text_to_copy = "Hello from rUNC! " .. math.random()
setclipboard(text_to_copy)

local read_text = getclipboard()
print("Copied:", text_to_copy)
print("Read:", read_text)
print("Match:", text_to_copy == read_text) --> true
</code></pre>
</div>
<h3>Как проверяется в rUNC</h3>
<p>Записывает случайное число в буфер обмена через `setclipboard`, а затем читает его с помощью `getclipboard` и сравнивает значения.</p>
</section>

<section id="mouse-emulation">
<h2>Эмуляция мыши</h2>
<p>Набор функций для программной симуляции движений и кликов мыши.</p>
<ul>
    <li><code>mouse1/2press/release/click()</code></li>
    <li><code>mousemoveabs(x, y)</code>, <code>mousemoverel(dx, dy)</code></li>
    <li><code>mousescroll(dx, dy)</code></li>
</ul>
<h3>Как проверяется в rUNC</h3>
<p>Создает UI-кнопку под курсором и проверяет, что вызовы `mouse1click`, `mouse1press`/`release`, `mouse2click` и `mouse2press`/`release` действительно вызывают соответствующие события `MouseButton1Click`, `MouseButton1Down`/`Up` и т.д. Остальные функции проверяются на отсутствие ошибок при вызове.</p>
</section>

<section id="actors-library">
<h2>Actors API</h2>
<p>Набор функций для работы с параллельными вычислениями в Roblox с использованием `Actor`.</p>
<ul>
<li><code>getactors()</code>: Возвращает все `Actor` в игре.</li>
<li><code>isparallel()</code>: Проверяет, выполняется ли код в параллельном режиме.</li>
<li><code>run_on_actor(actor, code)</code>: Выполняет код в контексте актора. Параллельные акторы обладают своими условиями, данные функции принадлежны для обхода систем безопасности (Свойственно для обхода анти читов)</li>
<li>Ого, ты дочитал до сюда, ты реально заинтересован?</li>
</ul>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет базовую работоспособность: `getactors` возвращает таблицу, `isparallel` возвращает boolean, а `create_comm_channel` возвращает ID и `BindableEvent`. Проверка выполнения кода на акторах (`run_on_actor`) тестируется на отсутствие ошибок.</p>
</section>

<section id="drawing">
<h2>Drawing</h2>
<p>Библиотека для рендеринга 2D-примитивов (линий, кругов, текста и т.д.) прямо на экране.</p>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>Создание объекта:</b> Проверяет, что `Drawing.new("Circle")` успешно выполняется и что результат проходит проверку `isrenderobj`.</li>
</ul>
</section>

<section id="debug-upvalues">
<h2>debug.(get/set)upvalue(s)</h2>
<p>Функции для интроспекции и модификации "upvalues" (внешних локальных переменных) Luau-функции.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет чтение и запись числовых upvalue'ов и upvalue'ов-функций, обработку невалидных индексов и ошибку на C-функциях.</p>
</section>

<section id="debug-constants">
<h2>debug.(get/set)constant(s)</h2>
<p>Функции для интроспекции и модификации таблицы констант Luau-функции.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что <code>getconstants</code> находит все типы констант (строки, числа, функции). Проверяет, что <code>setconstant</code> успешно меняет константу и это отражается на поведении функции.</p>
</section>

<section id="debug-stack">
<h2>debug.(get/set)stack</h2>
<p>Функции для низкоуровневой работы со стеком вызовов.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет изменение аргументов и локальных переменных в родительском и текущем скоупе, а также паттерн замены функции через `error()`. Проверяет чтение locals из вызывающего скоупа.</p>
</section>

<section id="debug-protos">
<h2>debug.getproto(s)</h2>
<p>Функции для работы с "прототипами" функций (шаблонами вложенных функций).</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет получение неактивных и активных прототипов, их вызов, а также ошибку на C-функциях.</p>
</section>

<section id="debug-metatable">
<h2>debug.setmetatable</h2>
<p>Версия `setmetatable`, которая игнорирует защиту `__metatable`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Аналогично `test_setrawmetatable`: подтверждает, что обычная `setmetatable` не работает, а `debug.setmetatable` успешно обходит защиту.</p>
</section>

<section id="debug-getinfo">
<h2>debug.getinfo</h2>
<p>Возвращает таблицу с информацией о функции или уровне стека вызовов.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет получение информации по объекту функции и по уровню стека. Убеждается, что все ожидаемые поля присутствуют.</p>
</section>

<section id="debug-more">
<h2>Другие debug-функции</h2>
<p>Набор дополнительных отладочных функций.</p>
<ul>
    <li><code>debug.setname(func, name)</code>: Устанавливает имя для функции, видимое в `debug.getinfo`.</li>
    <li><code>debug.isvalidlevel(level)</code>: Проверяет, существует ли указанный уровень в стеке вызовов.</li>
</ul>
<h3>Как проверяется в rUNC</h3>
<ul>
    <li><b>debug.setname:</b> Устанавливает имя и проверяет через `debug.getinfo`, что оно изменилось.</li>
    <li><b>debug.isvalidlevel:</b> Проверяет, что возвращает `true` для валидного уровня и `false` для невалидного.</li>
</ul>
</section>

<section id="crypto-base64">
<h2>crypt.base64*</h2>
<p>Функции для кодирования и декодирования строк в формат Base64.</p>
<h3>Как проверяется в rUNC</h3>
<p>Кодирует строку, затем декодирует результат и проверяет, что он совпадает с оригиналом (round-trip).</p>
</section>

<section id="crypto-encrypt">
<h2>crypt.encrypt/decrypt</h2>
<p>Функции для симметричного шифрования и дешифрования данных.</p>
<h3>Как проверяется в rUNC</h3>
<p>Генерирует ключ, шифрует строку, расшифровывает её тем же ключом и проверяет, что результат совпадает с оригиналом. Также проверяет, что расшифровка с неверным ключом не удается.</p>
</section>

<section id="crypto-generate">
<h2>crypt.generate*</h2>
<p>Функции для генерации криптографически стойких случайных данных.</p>
<h3>Как проверяется в rUNC</h3>
<p>Проверяет, что `generatekey` возвращает непустую строку, а `generatebytes` возвращает строку указанной длины.</p>
</section>

<section id="crypto-hash">
<h2>crypt.hash</h2>
<p>Вычисляет хэш строки, используя указанный алгоритм.</p>
<h3>Как проверяется в rUNC</h3>
<p>Хэширует одну и ту же строку дважды и убеждается, что результаты совпадают.</p>
</section>

<section id="compression">
<h2>lz4compress/decompress</h2>
<p>Функции для быстрого сжатия и распаковки данных с использованием алгоритма LZ4.</p>
<h3>Как проверяется в rUNC</h3>
<p>Сжимает строку, затем распаковывает ее, и проверяет, что результат в точности совпадает с исходной строкой.</p>
</section>

<section id="request">
<h2>request / http_request</h2>
<p>Отправляет HTTP(S) запрос и возвращает ответ.</p>
<h3>Как проверяется в rUNC</h3>
<p>Тест использует `httpbin.org` для проверки POST и GET запросов, а также обработки ошибок 404 и невалидных URL.</p>
</section>

<section id="file-ops">
<h2>Файловые операции</h2>
<p>Набор функций для работы с файлами: <code>writefile</code>, <code>readfile</code>, <code>appendfile</code>, <code>delfile</code>, <code>isfile</code>.</p>
<h3>Как проверяется в rUNC</h3>
<p>Тест последовательно выполняет все операции, проверяя создание, чтение, добавление, перезапись и удаление файла.</p>
</section>

<section id="folder-ops">
<h2>Операции с папками</h2>
<p>Набор функций для управления папками: <code>makefolder</code>, <code>isfolder</code>, <code>listfiles</code>, <code>delfolder</code>.</p>
<h3>Как проверяется в rUNC</h3>
<p>Тест проверяет создание, листинг содержимого и удаление папки.</p>
</section>

<section id="loadfile">
<h2>loadfile</h2>
<p>Читает файл, содержащий Lua-код, и компилирует его в функцию.</p>
<h3>Как проверяется в rUNC</h3>
<p>Создает файл с кодом, загружает его, проверяет, что функция работает. Затем перезаписывает файл неверным кодом и проверяет обработку ошибки.</p>
</section>

<section id="getcustomasset">
<h2>getcustomasset</h2>
<p>Преобразует локальный путь к файлу в формат `rbxasset://`.</p>
<h3>Как проверяется в rUNC</h3>
<p>Создает временный файл, вызывает для него `getcustomasset` и проверяет, что возвращаемая строка имеет валидный префикс.</p>
</section>

<section id="websocket">
<h2>WebSocket</h2>
<p>Клиентский класс для работы с WebSocket-соединениями.</p>
<h3>Конструктор, События и Методы</h3>
<ul>
    <li><code>WebSocket.connect(url)</code>: Создает соединение.</li>
    <li><code>OnMessage(message)</code>: Событие при получении сообщения.</li>
    <li><code>OnClose()</code>: Событие при закрытии соединения.</li>
    <li><code>Send(message)</code>: Отправка сообщения.</li>
    <li><code>Close()</code>: Закрытие соединения.</li>
</ul>
<h3>Как проверяется в rUNC</h3>
<p>Тесты для `WebSocket` исключены из `rUNC` из-за проблем со стабильностью. Раздел носит информационный характер.</p>
</section>

</div>
</main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const preloader = document.getElementById('preloader');
    window.addEventListener('load', () => {
        setTimeout(() => {
           preloader.classList.add('loaded');
        }, 300); 
    });


    document.addEventListener('click', (e) => {
        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        document.body.appendChild(ripple);

        ripple.style.left = `${e.clientX}px`;
        ripple.style.top = `${e.clientY}px`;
        
        setTimeout(() => {
            ripple.remove();
        }, 750);
    });


    const themeToggle = document.getElementById('themeToggle');
    const lightHljsTheme = document.getElementById('hljs-theme-light');
    const darkHljsTheme = document.getElementById('hljs-theme-dark');

    const applyTheme = (theme) => {
        if (theme === 'light') {
            document.documentElement.classList.add('light-theme');
            lightHljsTheme.removeAttribute('disabled');
            darkHljsTheme.setAttribute('disabled', 'disabled');
        } else {
            document.documentElement.classList.remove('light-theme');
            darkHljsTheme.removeAttribute('disabled');
            lightHljsTheme.setAttribute('disabled', 'disabled');
        }
    };

    const savedTheme = localStorage.getItem('runc_theme') || 'dark';
    applyTheme(savedTheme);

    themeToggle.addEventListener('click', () => {
        const currentTheme = document.documentElement.classList.contains('light-theme') ? 'light' : 'dark';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        localStorage.setItem('runc_theme', newTheme);
        applyTheme(newTheme);
    });


    hljs.highlightAll();
    const searchBar = document.getElementById('searchBar');
    const navLinks = document.querySelectorAll('#sidebar-nav ul li a');
    const navGroups = document.querySelectorAll('#sidebar-nav .sidebar-group-title');

    searchBar.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();
        
        navLinks.forEach(link => {
            const linkText = link.textContent.toLowerCase();
            const parentLi = link.parentElement;
            parentLi.style.display = linkText.includes(searchTerm) ? '' : 'none';
        });

        navGroups.forEach(group => {
            let nextElem = group.nextElementSibling;
            let hasVisibleLinks = false;
            while (nextElem) {
                if(nextElem.classList.contains('sidebar-group-title')) break;
                if(nextElem.tagName === 'LI' && nextElem.style.display !== 'none') {
                    hasVisibleLinks = true;
                    break;
                }
                nextElem = nextElem.nextElementSibling;
            }
            group.style.display = hasVisibleLinks ? '' : 'none';
        });
    });
    
    const sections = document.querySelectorAll('main section');
    const mainContent = document.querySelector('.main-content');
    
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const id = entry.target.getAttribute('id');
            const link = document.querySelector(`#sidebar-nav a[href="#${id}"]`);
            if (entry.isIntersecting && link) {
                 document.querySelectorAll('#sidebar-nav a.active').forEach(a => a.classList.remove('active'));
                link.classList.add('active');
            }
        });
    }, {
        root: mainContent,
        rootMargin: '0px 0px -75% 0px',
        threshold: 0
    });

    sections.forEach(section => observer.observe(section));
});


function copyCode(button) {
    const wrapper = button.closest('.code-block-wrapper');
    const code = wrapper.querySelector('pre code');
    navigator.clipboard.writeText(code.innerText).then(() => {
        const checkIcon = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 6L9 17L4 12" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
        const originalText = button.innerHTML;
        if(button.innerHTML.includes('Скопировано')) return;

        button.innerHTML = checkIcon + '<span>Скопировано!</span>';
        setTimeout(() => {
            button.innerHTML = originalText;
        }, 2000);
    }).catch(err => {
        console.error('Ошибка копирования', err);
        button.innerHTML = '<span>Ошибка!</span>';
    });
}
</script>
</body>
</html>
